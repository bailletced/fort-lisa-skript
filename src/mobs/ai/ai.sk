function mob_ai_init(mob: entity, ai: text):
  if {_ai} is "goToLisa0":
    set {_nearestEntrance} to location_castle_nearest_entrance({_mob})
    mob_store_location_set({_mob}, ({_nearestEntrance}, {LOCATION::CASTLE::FOUNTAIN}, {LOCATION::CASTLE::DOOR} and {LOCATION::CASTLE::THRONE}))
    mob_store_listener_set({_mob}, ("TARGET_PLAYER_RADIUS_SOFT"), "RADIUS", 20)
  else if {_ai} is "goToLisa1":
    mob_store_location_set({_mob}, mob_smartLocations({_mob}))
    mob_store_listener_set({_mob}, ("TARGET_PLAYER_RADIUS_SOFT"), "RADIUS", 5)
  else if {_ai} is "goToLisa2":
    mob_store_location_set({_mob}, mob_smartLocations({_mob}))
  else:
    error("AI %{_ai}% is not known")
  # Register mob AI...
  mob_ai_main_thread({_mob})

function mob_ai_main_thread(mob: entity):
  while {_mob} is alive:
    if mob_store_target_isset({_mob}) is false:
      if mob_store_location_get({_mob}) is set:
        mob_ai_targetLocation({_mob})
      else if mob_store_location_count({_mob}) is 0:
        mob_ai_target_findSomethingToDo({_mob})
    mob_ai_triggerListeners({_mob})
    wait 2 seconds

function mob_ai_triggerListeners(mob: entity):
  set {_disabledListeners::*} to mob_store_listener_get_all_disabled({_mob})
  loop {_disabledListeners::*}:
    mob_store_listener_enable({_mob}, loop-value)
    if loop-value is "TARGET_PLAYER_RADIUS_SOFT":
      mob_ai_listener_TARGET_PLAYER_RADIUS_SOFT({_mob})
    else if loop-value is "TARGET_ABANDON_TOO_FAR":
      mob_ai_listener_TARGET_ABANDON_TOO_FAR({_mob})
    else if loop-value is "IN_WATER":
      mob_ai_listener_IN_WATER({_mob})
    else:
      broadcast "LISTENER %loop-value% not implemented"


function mob_smartLocations(mob: entity) :: locations:
  set {_d1} to distance between {_mob} and {LOCATION::CASTLE::THRONE}
  set {_d2} to distance between {_mob} and {LOCATION::CASTLE::FOUNTAIN}
  if {_d1} < {_d2}:
    return {LOCATION::CASTLE::THRONE}
  return {LOCATION::CASTLE::FOUNTAIN} and {LOCATION::CASTLE::THRONE}




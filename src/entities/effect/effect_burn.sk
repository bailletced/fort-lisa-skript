function entity_effect_burn(source: entity, target: entity, attack: number, duration: number, frequency: number, option: text = "UNIQUE"):
  set {_amount} to floor({_duration} / {_frequency})
  if entity_store_effect_isset({_target}, "BURN") is false:
    entity_store_effect_init({_target}, "BURN", {_duration})
    entity_store_effect_add({_target}, "BURN", "damage", {_attack}*{_amount})
    entity_effect_burn_consume({_source}, {_target}, {_attack}, {_frequency})
  else:
    if {_option} is "EXTEND":
      entity_store_effect_add({_target}, "BURN", "duration", {_duration})
      entity_store_effect_add({_target}, "BURN", "damage", {_attack})
    else if {_option} is "ADD":
      entity_store_effect_add({_target}, "BURN", "duration", {_duration})
      entity_store_effect_add({_target}, "BURN", "damage", {_attack})
      entity_effect_burn_consume({_source}, {_target}, {_attack}, {_frequency})

function entity_effect_burn_consume(source: entity, target: entity, attack: number, delay: number):
  while entity_store_effect_isset({_target}, "BURN") is true:
    set {_uuid} to uuid of {_target}
    set {_target} on fire for "%{_delay}% ticks" parsed as timespan
    entity_store_effect_add({_target}, "BURN", "duration", -1*{_delay})
    entity_store_effect_add({_target}, "BURN", "damage", -1*{_attack})
    entity_effect_damage({_source}, {_target}, {_attack})
    wait "%{_delay}% ticks" parsed as timespan
#Get a given tag of an item
#Params:
#   it : item 
#   key: text Key of the stat to get
#Return:
#   object
function item_get_tag(it: item, key: text) :: text:
  set {_nbt} to full nbt compound of {_it}
  set {_res} to string tag "tag;%{_key}%" of {_nbt}
  if {_res} is not "":
    return {_res}

#Set a given stat of an item
#Params:
#   it : item 
#   key: text Key of the stat to get
#   value: object 
#Return:
#   item An item is returned because it is not possible to edit the nbt of an item without regenerating it
function item_set_tag(it: item, key: text, value: text) :: item:
  set {_nbt} to full nbt compound of {_it}
  set string tag "tag;%{_key}%" of {_nbt} to {_value}
  return item from nbt {_nbt}

#Determine if a given stat is defined for an item
#Params:
#   it : item 
#   key: text
#Return:
#   boolean
function item_isset_tag(it: item, key: text) :: boolean:
  set {_nbt} to full nbt compound of {_it}
  set {_res} to string tag "tag;%{_key}%" of {_nbt}
  if {_res} is not "":
    return true
  return false


#Set a given stat of an item
#Params:
#   it : item 
#   key: text Key of the stat to get
#   value: object 
#Return:
#   item An item is returned because it is not possible to edit the nbt of an item without regenerating it
function item_set_stat(it: item, key: text, value: number) :: item:
  set {_nbt} to full nbt compound of {_it}
  if {_value} is set:
    set float tag "tag;%{_key}%" of {_nbt} to {_value}
  return item from nbt {_nbt}

#Get a given stat of an item
#Params:
#   it : item 
#   key: text Key of the stat to get
#Return:
#   object
function item_get_stat(it: item, key: text) :: number:
  set {_nbt} to full nbt compound of {_it}
  set {_res} to float tag "tag;%{_key}%" of {_nbt}
  return {_res}

#Return all existing stats of an item
#   it : item 
#Return:
#   texts
function item_get_stats(it: item) :: texts:
  delete {_res::*}
  loop {STAT::ALL::*}:
    set {_stat} to loop-value
    if item_isset_stat({_it}, {_stat}) is true:
      add {_stat} to {_res::*}
  return {_res::*}

#Determine if a given stat is defined for an item
#Params:
#   it : item 
#   key: text
#Return:
#   boolean
function item_isset_stat(it: item, key: text) :: boolean:
  set {_nbt} to full nbt compound of {_it}
  set {_res} to tag "tag;%{_key}%" of {_nbt}
  if {_res} is set:
    return true
  return false

#Return all stats of an item superior to a given amount
#   it : item 
#   amount: number
#Return:
#   texts
function item_get_stats_superior_to(it: item, amount: number) :: texts:
  delete {_res::*}
  loop {STAT::ALL::*}:
    set {_stat} to loop-value
    if item_isset_stat({_it}, {_stat}) is true:
      set {_statItemAmount} to item_get_stat({_it}, {_stat})
      if {_statItemAmount} > {_amount}:
        add {_stat} to {_res::*}
  return {_res::*}

#Return a random existing stat of an item
#   it : item 
#   exludedStats: text Stats separated with a ;
#   greaterThan: number
#Return:
#   text
function item_get_stat_random(it: item, exludedStats: text, greaterThan: number) :: text:
  set {_exludedStats::*} to {_exludedStats} split at ";"
  set {_itemStats::*} to item_get_stats_superior_to({_it}, {_greaterThan})
  set {_res} to random element of {_itemStats::*}
  while {_exludedStats::*} contains {_res}:
    if length of {_itemStats::*} is 0:
      stop loop
    remove {_res} from {_itemStats::*}
    set {_res} to random element of {_itemStats::*}
  return {_res}

#Add an amount of stat from item
#Params:
#   it : item 
#   key: text
#   amount: number
#Return:
#   item
function item_add_stat(it: item, key: text, amount: number) :: item:
  if item_isset_stat({_it}, {_key}) is true:
    set {_currentAmount} to item_get_stat({_it}, {_key})
    set {_finalAmount} to {_currentAmount} + {_amount}
    set {_item} to item_set_stat({_it}, {_key}, {_finalAmount})
  else:
    set {_item} to item_set_stat({_it}, {_key}, {_amount})
  return {_item}


#Affect stats to item
function item_stat_initialize(p: player, type: text, item: item) :: item:
  set {_category} to item_get_tag({_item}, "CATEGORY")
  set {_id} to item_get_tag({_item}, "ID")
  loop {STAT::%{_type}%::*}:
    set {_stat} to loop-value
    set {_value} to {%{_type}%::%{_category}%::%{_id}%::%loop-value%}
    if {_value} is set:
      set {_item} to item_set_stat({_item}, {_stat}, {_value})
  set {_item} to item_set_stat({_item}, "CD_NORMAL", 0)
  set {_item} to item_set_stat({_item}, "CD_SPECIAL", 0)
  return {_item}

function item_create(p: player, type: text, category: text, id: text) :: item:
  set {_uuid} to item_generate_uuid({_type}, {_category}, {_id})
  set {_item} to {WEAPON::%{_category}%::%{_id}%::ITEM}
  set {_item} to item_set_tag({_item}, "TYPE", {_type})
  set {_item} to item_set_tag({_item}, "CATEGORY", {_category})
  set {_item} to item_set_tag({_item}, "ID", {_id})
  set {_item} to item_set_tag({_item}, "UUID", {_uuid})
  set {_item} to item_stat_initialize({_p}, "WEAPON", {_item})
  set {_item} to i18n_item({_p}, {_item})
  return {_item}

function item_generate_uuid(type: text, category: text, id: text) :: text:
  add 1 to {IDS::%{_type}%::%{_category}%::%{_id}%}
  return "%{_type}%/%{_category}%/%{IDS::%{_type}%::%{_category}%::%{_id}%}%"

function item_give(p: player, type: text, category: text, id: text):
  if {_type} is "WEAPON":
    weapon_give({_p}, {_category}, {_id})